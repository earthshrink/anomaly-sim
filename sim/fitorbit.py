"""Least square fit of orbital elements under a perturbation"""

from datetime import datetime

from astropy import units as u

from poliastro.bodies import Earth
from poliastro.frames import Planes
from poliastro.util import norm
from poliastro.twobody.orbit import Orbit
from poliastro.twobody.sampling import EpochsArray

from lmfit import Parameters, minimize, fit_report

import numpy as np

class OrbitFitter:
    """Fitter of poliastro orbits to range or Doppler data"""

    # pylint: disable=too-many-instance-attributes

    def __init__(self, orbit, stations, var=0.001, max_iter=100, trace=False, debug=False):
        """Reference orbit and tracking stations to which the perturbations must be minimized."""

        self._debug = debug
        self._trace = trace

        # compute min/max for critical parameters
        aref = orbit.a.to_value(u.m)
        amin = aref * (1-var)
        amax = aref * (1+var)

        eref = orbit.ecc.to_value(u.one)
        emin = eref * (1-var)
        emax = eref * (1+var)

        iref = orbit.inc.to_value(u.rad)
        imin = iref * (1-var)
        imax = iref * (1+var)

        if debug:
            print("Range constraints:")
            print("a:", amin, amax)
            print("ecc:", emin, emax)
            print("inc:", imin, imax)
            if max_iter:
                print("max iter:", max_iter)

        params = Parameters()
        params.add('a', min = amin, max = amax, value = aref)
        params.add('ecc', min = emin, max = emax, value = eref)
        params.add('inc', min = imin, max = imax, value = iref)
        params.add('nu', min = -np.pi, max = np.pi, value = orbit.nu.to_value(u.rad))
        params.add('raan', min = 0, max = 2*np.pi, value = orbit.raan.to_value(u.rad))
        params.add('argp', min = 0, max = 2*np.pi, value = orbit.argp.to_value(u.rad))

        self._ref_params = params
        self._stations = stations
        self._epoch = orbit.epoch
        self._maxiter = max_iter
        self._runtime = None

        # computed by fitting
        self._orbit = None
        self._ephem = None
        self._result = None
        self._params = []
        self._resid = []


    def param(self, name):
        """Access parameters by name, to set constraints."""
        return self._ref_params[name]

    @property
    def result(self):
        """LMfit result"""
        return self._result

    def report(self):
        """LMfit report"""
        return fit_report(self._result)

    @property
    def orbit(self):
        """Last orbital elements visited by fit"""
        return self._orbit

    @property
    def ephem(self):
        """Last ephemeris generated by fit"""
        return self._ephem

    @property
    def runtime(self):
        """Last fit execution time if any"""
        return self._runtime


    def _iter_trace(self, iternum, params, resid):

        if self._trace:
            self._params.append(params)
            self._resid.append(resid)

        if self._debug:
            _norm = "()"
            if resid:
                _norm = norm(resid*u.one)
            print(f'{iternum}. {_norm} {params.valuesdict()}')

        if self._maxiter:
            return self._maxiter <= iternum

        return False


    def range_residual(self, times, data, wts=None):
        rres = []
        for i, e in enumerate(times):
            rv = self._ephem.rv(e)
            datum = data[i]
            if wts is None or i >= len(wts):
                wt = 1
            else:
                wt = wts[i]
            for si, sv in enumerate(self._stations):
                meas_r = datum[si]
                if np.isnan(meas_r):
                    rres.append(0)
                else:
                    model_r, _ = sv.range_and_rate(rv, e)
                    rres.append((model_r - meas_r).to_value(u.m)*wt)
        return rres

    def doppler_residual(self, times, data, wts=None):
        rres = []
        for i, e in enumerate(times):
            rv = self._ephem.rv(e)
            datum = data[i]
            if wts is None or i >= len(wts):
                wt = 1
            else:
                wt = wts[i]
            for si, sv in enumerate(self._stations):
                meas_rr = datum[si]
                if np.isnan(meas_rr):
                    rres.append(0)
                else:
                    _, model_rr = sv.range_and_rate(rv, e)
                    rres.append((model_rr - meas_rr).to_value(u.m/u.s)*wt)
        return rres


    def _compute_trajectory(self, params, times):
        vals = params.valuesdict()

        self._orbit = Orbit.from_classical(attractor = Earth,
                                     a=vals['a'] * u.m,
                                     ecc=vals['ecc'] * u.one,
                                     inc=vals['inc'] * u.rad,
                                     raan=vals['raan'] * u.rad,
                                     argp=vals['argp'] * u.rad,
                                     nu=vals['nu'] * u.rad,
                                     epoch = min(self._epoch, times[0]),
                                     plane = Planes.EARTH_EQUATOR)
        self._ephem = self._orbit.to_ephem(EpochsArray(times))


    def _range_residual(self, params, times, data, wts=None):
        self._compute_trajectory(params, times)
        return self.range_residual(times, data, wts)


    def fit_range_data(self, times, data, weights=None, method='leastsq'):
        """Method to fit orbital elements to range data"""

        def res_func(pars, times, dats, wts):
            return self._range_residual(pars, times, dats, wts)

        def tr_func(pars, iternum, resid, *_args, **_kws):
            return self._iter_trace(iternum, pars, resid)

        started = datetime.now()
        self._result = minimize(res_func, self._ref_params,
            args=(times,), kws={'dats': data, 'wts': weights}, iter_cb=tr_func, method=method)
        self._runtime = datetime.now() - started


    def _doppler_residual(self, params, times, data, wts=None):
        self._compute_trajectory(params, times)
        return self.doppler_residual(times, data, wts)


    def fit_doppler_data(self, times, data, weights=None, method='leastsq'):
        """Method to fit orbital elements to doppler or range-rate data"""

        def res_func(pars, times, dats, wts):
            return self._doppler_residual(pars, times, dats, wts)

        def tr_func(pars, iternum, resid, *args, **kws):
            return self._iter_trace(iternum, pars, resid)

        started = datetime.now()
        self._result = minimize(res_func, self._ref_params,
            args=(times,), kws={'dats': data, 'wts': weights}, iter_cb=tr_func, method=method)
        self._runtime = datetime.now() - started


    def fit_rangerates_to_range_data(self, times, rdata, weights=None, method='leastsq'):
        """Method to fit orbital elements to the range rates implied by range data"""

        rrdata = []
        for i, t in enumerate(times[1:]):
            dt = t - times[i-1]
            nowr = rdata[i]
            wasr = rdata[i-1]
            rrdata.append([ (nowr[si] - wasr[si])/dt for si, sv in enumerate(self._stations) ])

        self.fit_doppler_data(times[:-1], rrdata, weights, method)
